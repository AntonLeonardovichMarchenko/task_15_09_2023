import makers
import random
import secrets
import string
import time

# Генераторы и итераторы - это инструменты, которые, как правило, используются
# для поточной обработки данных. Назначение итератора – это упрощение навигации по
# элементам объекта, который, как правило, представляет собой некоторую коллекцию
# (список, словарь и т.п.).
#
# списки предназначены для многократного использования с возможностью применения в нескольких
# (возможно, что сразу в нескольких) итерациях.
#
# итераторы (объекты - представители классов итераторов, которые могут при определённых
# условиях выполнять функцию перебора значений), возможности многократного применения не
# предоставляют, т.к. относятся к одноразовым инструментам. Очередная попытка получения
# нового значения, которая обеспечивается методом __next__(), приводит к изменению
# значения счётчика количества обращений к итератору. После определённого количества обращений
# объект итератора становится непригодными для дальнейших итераций.
#
# Основное место применения итераторов и генераторов – это цикл for. Если перебирать элементы в
# некотором списке или символы в строке с помощью цикла for, то, фактически, это означает, что при
# каждой итерации цикла происходит обращение к итератору, содержащемуся в строке/списке, с
# требованием выдать очередной элемент (элемент-представитель какого-либо класса).
# Если итератор или генератор больше не может выдавать элементы (например, в результате ограничений
# по количеству возвращаемых элементов), то итератор возбуждает исключение, которое обеспечивает
# выход из цикла.

# Создание собственных итераторов (пример итератора, возвращающего единицы)
# Если нужно получить элементы от итератора собственного класса, необходимо определить
# собственный класс итератора. Для этого надо создать класс, объект которого и будет итератором.
# Далее представлен объект-представитель ранее определённого класса итератора, который как и ранее
# в цикле возвращает определенное количество единиц, задаваемое в конструкторе при создании
# объекта итератора.
# Этот класс итератора содержит конструктор, принимающий на вход количество единиц и
# метод __next__(), который обеспечивает работу объекта данного класса как итератора.
# В этом примере при четвертом обращении к итератору (вызове функции next()) будет
# возбуждено исключение StopIteration, которое нужно будет перехватить в коде и
# выполнить соответствующие действия (например, выход из цикла).

# класс одноразовый итератор. Возвращает единицы. Количество обращений задаётся
# значением атрибута self.limit
class SimpleIterator_0:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration # это исключение обеспечивает выход из внешнего цикла

# Простой несамовзводный итератор НЕ будет работать больше, чем это было
# задано в значении атрибута, который определяет количество обращений к объекту итератора
def SMPL_0(limit, num):

    s_iter0 = SimpleIterator_0(limit)

    # for i in range(100):
    #     try:
    #         print(f'{i}...{s_iter0.counter}-{next(s_iter0)}')
    #     except StopIteration:
    #         pass


    for i in range(num):
        try:
            print(f'{i}...{s_iter0.counter}-{next(s_iter0)}')   # очередное обращение к итератору
            i += 1
        except StopIteration:
            print(f'Iteration error in {i} step')
            # pass
            break
        else:
            print(f':{i}')

# многоразовые самосбрасывающиеся итераторы. Самосброс таких итераторов
# обеспечивается методом __iter__ и состоит в обнулении счётчика итератора self.counter

# класс многоразовый самосбрасывающийся итератор SimpleIterator_1.
# Самосброс такого итератора обеспечивается методом __iter__ и состоит
# в обнулении счётчика итератора self.counter
class SimpleIterator_1:
    def __iter__(self):
        self.counter = 0

    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            self.__iter__()         # сброс - обнуление счётчика итератора
            raise StopIteration     # выход из внешнего цикла

def SMPL_1(limit, num = 0):     # самосбрасываемый итератор
    s_iter1 = SimpleIterator_1(limit)

    i = 0
    while True:
        try:
            print(next(s_iter1))   # очередное обращение к итератору
            i += 1
        except StopIteration:
            print(f'Iteration error in {i} step')
            break
        else:
            print(f'*{i}')

    # повторное обращение к самосбрасываемому итератору:

    i = 0
    while True:
        try:
            print(next(s_iter1))  # очередное обращение к итератору
            i += 1
        except StopIteration:
            print(f'Iteration error in {i} step')
            break
        else:
            print(f'*{i}')

    # тот же САМЫЙ самосбрасываемый (самозарядный) итератор выступает в роли сумматора.
    # Здесь нет вспомогательных переменных (i). Здесь показана работа -
    # итератора - изменение значения атрибута self.counter относительно значения
    # атрибута self.limit.
    result = 0
    while True:
        try:
            result += next(s_iter1)  # очередное обращение к итератору
        except StopIteration:
            print(f'Iteration error in {i} step')
            break
        else:
            print(f'*{s_iter1.counter}*{s_iter1.limit}*')

        print(f'>>>{result}<<<')

    # повторное обращение к самосбрасываемому итератору, который используется как сумматор:

    result = 0
    while True:
        try:
            result += next(s_iter1)  # очередное обращение к итератору
        except StopIteration:
            print(f'Iteration error in {i} step')
            break
        else:
            print(f'+{s_iter1.counter}+{s_iter1.limit}+')

        print(f'###{result}###')


# класс многоразовый итератор SecretsIterator.
# при обращении к объекту итератора SecretsIterator возвращается строка случайных
# символов. Количество обращений к объекту определяется значением параметра limit = 10
# (значение по умолчанию), после чего производится самосброс итератора.
class SecretsIterator:
    def __iter__(self):
        self.counter = 0

    def __init__(self, limit = 10):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return makers.makeSecrets()  # случайная последовательность символов
                                         # фиксированной дины (задаётся по умолчанию)
        else:
            self.__iter__()      # сброс - обнуление счётчика итератора
            raise StopIteration  # выход из внешнего цикла


# применение самосбрасываемого итератора SecretsIterator
def ScrItr(limit, num = 100):     # самосбрасываемый итератор SecretsIterator

    if limit <= 0:
        scrIter = SecretsIterator()
    else:
        scrIter = SecretsIterator(limit)

    for i in range(num):
        try:
            print(f'{i}...{scrIter.counter}-{next(scrIter)}')
        except StopIteration:
            pass


# Объект итератора RandIterator возвращает случайное чисел типа float в диапазоне значений,
# которое задаётся значением base = 1 (по умолчанию) с двумя знаками после запятой.
# Количество обращений к объекту определяется значением параметра limit = 10 (значение
# по умолчанию), после чего производится самосброс итератора.
#
class RandIterator:
    def __iter__(self):
        self.counter = 0

    def __init__(self, limit = 10, base = 1):
        self.limit = limit
        self.counter = 0
        self.base = base

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1

            # ============================================================
            # Случайное число
            # способы ограничения количества знаков после запятой:
            # они различаются!

            # 1. ограничение количества знаков строкой
            return float(f'{self.base * random.random():.2f}')

            # 2. ограничение количества знаков приведением, умножением и делением.
            #return int(self.base * random.random()*100)/100

            # случайное значение типа float - результат с двумя знаками после запятой -
            # как результат произведения значения self.base на случайное число в
            # диапазоне 0.0 - 1.0
        else:
            self.__iter__()      # сброс - обнуление счётчика итератора
            raise StopIteration  # выход из внешнего цикла

# применение самосбрасываемого итератора RandIterator.
# Первый параметр - значения для настройки итератора (пустой список
# устанавливает значения по умолчанию)
# Второй параметр - количество обращений к итератору
def RndItr(iterArgs, num = 100):

    if iterArgs == []:
        rndIter = RandIterator()
    else:
        rndIter = RandIterator(iterArgs[0], iterArgs[1])

    for i in range(num):
        try:
            print(f'{i}...{rndIter.counter}-{next(rndIter)}')
        except StopIteration:
            pass

# ========================================================================

    # Генераторы
    # Генераторы позволяют упростить работу по конструированию итераторов. В предыдущих примерах,
    # для построения итератора и работы с ним, создавался отдельный класс. Генератор – это ФУНКЦИЯ,
    # (определение функции генератора - за пределами  dictionsGenerate) которая будучи вызванной в
    # функции next() возвращает следующий объект согласно определённому в функции алгоритму.
    # Эти функции работают также, как и объекты класса SimpleIterator_... из предыдущего примера.
    # Вместо ключевого оператора return (смотри объявления класса итератора) в генераторе
    # используется оператор yield. И это связано с тем, что работа генератора обеспечивается работой
    # функции, из которой нельзя выходить на протяжении всего времени работы генератора.
    # После генерации очередного значения, функция-генератор возвращает это значение с помощью
    # оператора yield и при этом не прекращает свою работу (выход из функции), а “замораживается”
    # до очередной итерации, запускаемой функцией next().
    # Если в генераторе, где-то в коде используется оператор return, то в этом месте будет
    # возбуждено исключение StopIteration, а если после оператора return поместить какую-либо
    # информацию (например, строку), то она будет добавлена к описанию исключения StopIteration.
    #


    # Генератор. Здесь это функция, объект-ссылка на которую по мере обращения к ней
    # генерирует количество единиц, задаваемое параметром val.
    # Оператор yield НЕ допускает возбуждения исключения StopIteration
def simple_generator(val):

    while val > 0:
        val -= 1
        yield 1

    # Ещё один генератор. Функция обеспечивает генерацию единиц, количество которых
    # задаваётся параметром val. Параметр stop (по умолчанию равный -1) в этой версии
    # генератора определяет значение параметра val, при котором вместо оператора yield,
    # который НЕ допускает возбуждения исключения StopIteration, выполняется оператор return,
    # в результате выполнения которого возбуждается исключение StopIteration с передачей
    # соответствующего значения (строки)

def simple_generator_ret(val, stop=-1):

    while val > 0:
        val -= 1

        if val > stop:
            yield 1
        else:
            return 'warning! generator is STOPPED'

# Работа генератора представлена на примере.
def generatorsExample():

    gen_iter = simple_generator(5)

    i = 0
    while True:
        try:
            print(f'{i}_{next(gen_iter)}')
            i += 1
        except StopIteration:
            print(f'Generation error in {i} step')
            break
        else:
            print(f'^{i}')

    # и в чём простота? в том, что не надо объявлять класс-итератор?
    # по сути - это такой же одноразовый объект (ссылка на функцию), которая является
    # аргументом функции next. Разница в том, что генератор нельза определить как
    # самосбрасываемый (упрощение...)

    i = 0
    while True:
        try:
            print(f'{i}_{next(gen_iter)}')
            i += 1
        except StopIteration:
            print(f'Generation error in {i} step')
            break
        else:
            print(f'^{i}')

    # в процессе генерации (цикл для получения очередного генерируемого объекта)
    # может быть непосредственно задействована сама функция-генератор, а не ссылка
    # на эту функцию.

    for i in range(10, 0, -1):
        try:
            print(f'{i}_{next(simple_generator(i))}')
            i -= 1
        except StopIteration:
            print(f'Generation error in {i} step')
            break
        else:
            print(f'>>{i}')

    # генератор с программируемым количеством генерируемых объектов.
    # В генераторе simple_generator_ret(arg1, arg2) определены два параметра. При обращении
    # к этому генератору значения соответствующих атрибутов можно задавать различными способами.
    # Сам объект генератора при работе уменьшает значение arg1.
    # arg2 является пороговым значением для данного генератора. Если arg1 оказывается
    # меньше значения arg2, генератор с помощью ОПЕРАТОРА return (который возбуждает исключение
    # StopIteration) возвращает строку, которая добавляется к описанию исключения StopIteration.

    # При таких значениях аргументов возбуждается исключение, которое надо перехватить.
    print('!!!!!!!!!! simple_generator_ret(100, 50) !!!!!!!!!!')
    sgr = simple_generator_ret(100, 50)
    j = 0
    i = 0

    while True:

        try:
            next(sgr)
            i += 1
            j += i
        except StopIteration as st:
            print(f'>>>>>>>>>>{st}<<<<<<<<<<')
            break
        else:
            print(f'{i} ..... {j}')

    print('!!!!!!!!!! simple_generator_ret(100, -50) !!!!!!!!!!')
    # В этом случае исключение НЕ возбуждается
    sgr = simple_generator_ret(100, -50)
    j = 0
    i = 0

    while True:

        try:
            next(sgr)
            i += 1
            j += i
        except StopIteration as st:
            print(f'>>>>>>>>>>{st}<<<<<<<<<<')
            break
        else:
            print(f'{i} ..... {j}')

    # В этом случае значение второго аргумента задаётся по умолчанию и исключение
    # StopIteration также НЕ возбуждается.
    print('!!!!!!!!!! simple_generator_ret(100) !!!!!!!!!!')
    sgr = simple_generator_ret(100)
    j = 0
    i = 0

    while True:

        try:
            next(sgr)
            i += 1
            j += i
        except StopIteration as st:
            print(f'::::::::::{st}::::::::::')
            break
        else:
            print(f'{i} ..... {j}')

    # генератор списка кортежей (строка, целочисленное значение)
    listIter = (('key_' + str(i), i) for i in range(100))
    # структура генерируемого объекта -
    # кортеж из строки и целочисленного
    # значения
    #                                   алгоритм сборки -
    #                                   перебор значений в
    #                                   диапазоне range(100)
    for lg in listIter:
        print(lg[0], lg[1])
    print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')

    # 1. итераторы и генераторы имеют много преимуществ, основным из которых является
    #    эффективность использования памяти.
    # 2. простые итераторы и генераторы не предназначены для повторного использования.
    #    Но не каждый повторяющийся процесс (работа итераторов и генераторов) можно просто
    #    перезапустить. Вместо этого нужно воссоздать тот же итератор, если повторный запуск
    #    этого процесса безопасен.
    # 3. Итератор и генератор работают как бегущая строка. Когда вызывается его next,
    #    он выдает следующий элемент, но затем забывает его, в отличие от списка.
    #    Именно отсюда проистекает большая часть эффективности. Поскольку им не нужно запоминать,
    #    какими были их предыдущие значения, объем памяти намного меньше (особенно когда не все
    #    их значения в конечном итоге могут понадобиться!)

    # неудачные попытки повторного применения не самосбрасываемого
    # ранее использованого  простого итератора ===========================
    for lg in listIter:
        print(lg[0], lg[1])
    # Необходима повторная генерация итератора.
    # генератор списка кортежей (строка, целочисленное значение)
    listIrer = (('key_' + str(i), i) for i in range(100))

    print('================================================')
    dictIter = dict(((lg[0], lg[1]) for lg in listIter))

    # Создание словаря
    # словарь dictIter построен. И если dict - это функция, то dictIter является
    # ГЕНЕРАТОРОМ. Если  dict - это класс, а dict(...) - его конструктор, то dictIter -
    # простой итератор, который НЕ допускает возможность самосброса!
    # Так что в этом случае между итератором и генератором НЕТ НИКАКОЙ РАЗНИЦЫ.

    for dt in dictIter:
        print(dt)

    print('********************************************************')

    for dt in dictIter:
        print(dt)

    # ====================================================================

# ========================================================================
# Декоратор (от англ. decorator) – это функция, которая используется в качестве «обертки»
# другой функции для изменения ее поведения или расширения функциональности БЕЗ непосредственного
# изменения кода самой функции.
#
# Декораторы могут быть полезны для расширения возможностей функций из сторонних библиотек,
# код которых невоможно изменить, а также для изменения поведения или расширения функциональности
# методов классов. Все что нужно - это написать собственный или использовать уже готовый
# декоратор с требуемой дополнительной функциональностью и передать ему объект целевой функции
# или метода ДЛЯ ДЕКОРИРОВАНИЯ. Возможности декорирования ограничены. Всегда ПРОЩЕ написать
# НОВУЮ функцию, чем засовывать одну и ту же функцию в декоратор.

# декораторы функций в общем случае принимают на вход исходную версию какой-либо функции
# или метода, а возвращают обертку переданной функции или метода, но уже с дополнительной
# функциональностью. При этом в случаях, когда исходная версия функции становится больше
# не нужна, возвращаемую декоратором обертку присваивают переменной с именем исходной функции,
# тем самым полностью заменяя ее.

# объект декорирования - функция summator... для большей наглядности =====
# размещена в модуле makers ==============================================
# def summator(values, ret=None):
#
#     for val in values:
#         ret = ret + val
#     return ret
# ========================================================================

def Decorators(fun):   # функция Decorators содержит ОБОЛОЧКУ декорирвания -
                       # ОПРЕДЕЛЕНИЕ новой функции, которая декорирует декорируемую
                       # функцию. Её имя (здесь это wrapperFunXXX) совсем НЕ важно.
                       # Важно, что в этом определении действительно происходит
                       # "украшение" декорируемой функции. Декорируемая функция заменяется
                       # оболочкой декорирования, которую возвращает декоратор.
                       # Возможности декорирования ограничены тем, что сам код декорируемой
                       # функции нельзя изменить по ссылке, которую получает функция -
                       # декоратор. В данном случае - это функция Decorators



    # определение новой функции взамен декорируемой.
    # Список параметров НЕ меняется, так как она сделана для нотации с префиксом @.
    def wrapperFun(args, xarg):

        # Здесь декорирование сводится к модификации списка параметров
        print(f'wrapperFun({args}, {xarg})')
        argWrap = []
        for j in range(0, len(args)):
            secret = ''.join(secrets.choice(string.ascii_letters + string.digits) for x in range(10))
            argWrap.append(f'argument: {args[j]} {secret} \n')

        # после этого в теле wrapperFunXXX вызывается декорируемая функция с изменённым
        # списком параметров, перехватывается её возвращаемое значение, которое возвращается
        # оболочкой декорирования. Выходит, что не случайно весь этот прибамбас
        # называют ОБОЛОЧКОЙ!
        ret = fun(argWrap, '')   # ну вот и сам запуск декорируемой функции.
        return ret               # и возвращение перехваченного возвращаемого
                                 # результата декорируемой функции
    # ====================================================================

    return wrapperFun        # Decorators возвращает ссылку на
                             # отдекорированную функцию.
                             # На входе fun на выходе wrapperFun


def DecoratorsWithArgs(fun):  # функция Decorators содержит ОБОЛОЧКУ декорирвания
                                       # и сама имеет параметр. Может быть, он пригодится.


# ОПРЕДЕЛЕНИЕ новой функции, которая декорирует декорируемую
# функцию. Её имя (здесь это wrapperFunWithArgs) совсем НЕ важно.
# Важно, что в этом определении действительно происходит
# "украшение" декорируемой функции. Декорируемая функция заменяется
# оболочкой декорирования, которую возвращает декоратор.
# Возможности декорирования ограничены тем, что сам код декорируемой
# функции нельзя изменить по ссылке, которую получает функция -
# декоратор. В данном случае - это функция DecoratorsWithArgs.
# Однако в оболочку декодирования можно внедрить параметры, которые,
# возможно, смогут повлиять на работу декорированной функции.


# определение новой функции взамен декорируемой.
# Список параметров НЕ меняется, так как она сделана для нотации с префиксом @.
    def wrapperFunWithArgs(args, argsLst):
        # Здесь декорирование сводится к модификации списка параметров
        if argsLst[0] == 0 and argsLst[1] == 0:
            argsLst[0] = '+'
            argsLst[1] = -1

        print(f'wrapperFunWithArgs {args}, {argsLst[0], argsLst[1]}')
        if argsLst[0] == '':
            argWrap = []
            for j in range(0, len(args)):
                secret = ''.join(secrets.choice(string.ascii_letters + string.digits) for x in range(10))
                #secret = secret + '_____'
                argWrap.append(f'argument: {args[j]} {secret} {argsLst[1]}')
        elif argsLst[0] == '+':
            argWrap = []
            for j in range(0, len(args)):
                secret = ''.join(secrets.choice(string.ascii_letters + string.digits) for x in range(10))
                # secret = secret + '_____'
                argsLst[1] += 1
                argWrap.append(f'argument: {args[j]} {secret} {str(argsLst[1])}')

        else:
            argWrap = args


        # после этого в теле wrapperFunXXX вызывается декорируемая функция с изменённым
        # списком параметров, перехватывается её возвращаемое значение, которое возвращается
        # оболочкой декорирования. Выходит, что не случайно весь этот прибамбас
        # называют ОБОЛОЧКОЙ!

        if argsLst[0] == 0:
            ret = fun(argWrap, argsLst)  # ну вот и сам запуск декорируемой функции.
        else:
            ret = argWrap

        return ret  # и возвращение перехваченного возвращаемого
        # результата декорируемой функции


# ====================================================================

    return wrapperFunWithArgs  # Decorators возвращает ссылку на
                               # отдекорированную функцию.
                               # На входе fun на выходе wrapperFunWithArgs


# Декораторы =============================================================

@Decorators
def summator_0(values, ret=0):
    print(f'summator_0 {values}')
    if ret == 0:
        for val in values:
            ret = ret + val
    elif ret == '':
        for val in values:
            ret = ret + str(val)
    return ret

# DecoratorsWithArgs модифицирует входные параметры.
# если этот декоратор отключить, то при определённых значениях параметра
# argsLst ([0,0]) summator_1 вернёт другой результат.
@DecoratorsWithArgs
def summator_1(values, argsLst):

    if argsLst[0] == 0:
        ret = 0
        for val in values:
            ret = ret + val
        return ret
    elif argsLst[0] == '':
        ret = []
        for val in values:
            ret.append( str(val) + argsLst[1] )
        return ret

def GoDecorators_0():

    xargs = []
    for i in range(10):
        xargs.append(i)

    # В объекте декорирования - функции summator операция суммирования (+) определена
    # как для чисел, так и для строк. Это даёт возможность декорировать функцию summator,
    # перенастраивая её для работы со строками. Декорирование состоит в преобразовании списка
    # значений аргумента и изменении базы для суммирования (пустая строка вместо
    # челочисленного нуля).
    # Поскольку декораторы используются довольно часто, для упрощения процедуры
    # получения декорированных объектов (функций) используется специальный синтаксис,
    # предусматривающий использование имени декоратора с префиксом в виде символа @
    # непосредственно перед строкой, содержащей заголовок определения декорируемой функции
    # или метода. При такой нотации декорируемая функция фактически декорируется САМА В СЕБЯ!
    # При этом этом функция-декоратор и декорируемая функция должны находиться в ОДНОМ модуле!

    # изначально эта функция суммирует значения списка целых чисел
    res = makers.summator(xargs, 0)  # второй аргумент задаёт базу для суммирования целых чисел
    print("makers.summator Before decoration")
    print(res)

    # декорирование функции меняет значения аргумента (на основе целых чисел
    # строится список строк), после чего производит суммирование
    # (в функции определён оператор суммирования) этих строк в одну строку с
    # добавлением случайной строки и символом перехода на новую строку.
    DecoratedSummator = Decorators(makers.summator)
    res = DecoratedSummator(xargs,'')  # Второй аргумент, по умолчанию установленный в
                                    # 0, корректируется декоратором в None (значение по
                                    # умолчанию)
    # # (задаётся база для суммирования строк)
    print("makers.summator After decoration")
    print(res)


def GoDecorators_1(lstArg):
    xargs = []
    for i in range(10):
        xargs.append(i)

    # это результат декорирования в стиле @<имя_декоратора>
    #                                     <имя функции>
    #                           при этом функция-декоратор и ДЕКОРИРОВАННАЯ
    #                           функция должны находиться в ОДНОМ модуле!

    res = summator_1(xargs, lstArg)

    print('summator_1 before decoration')
    if isinstance(res, int):
        print(res)
    else:
        for r in res:
            print(r)

    # это исправляется. Далее представлена модификация функции при
    # помощи явного вызова функции-декоратора с передачей ему в качестве
    # аргумента декорируемой функции, которая расположена в другом модуле.
    # Но и здесь существуют свои ограничения.
    # Ссылка на объект, который представляет собой ссылку на возвращаемую
    # декоратором функцию, должен находиться в одном модуле с декоратором.


    # ссылка на результат декорирования НЕ является ссылкой
    # на декорируемую функцию.
    lstArg = ['', 'qazwsxedc']
    DecoratedSummatorWithArgs = DecoratorsWithArgs(summator_1)
    res = DecoratedSummatorWithArgs(xargs, lstArg)
    print('summator_1 after decoration')
    if isinstance(res, int):
        print(res)
    else:
        for r in res:
            print(r)

    print()

# ========================================================================
# time meters измерители времени выполнения.
# timeTestFunction_0 и timeTestFunction_1 декорируются декораторами
# timerDecorator_0 timerDecorator_1. Они обеспесчивают выполнения соответствующими
# timerDecoratorWrap'ами и преобразуют исходные функции. Декорированные функции
# вызываются как обыкновенные функции. Только с расширенным функционалом.
# В первом случае это всего лишь измерение времени выполнения функции,
# которое обеспечивает timerDecorator_0, во втором случае - это выполнение
# декорированной функции timeTestFunction_1 большого количества раз, которое
# зависит от диапазона, кототорый определяется в timerDecoratorWrap_1
# ========================================================================

def timerDecorator_0(function):

    def timerDecoratorWrap_0(value):
        start = time.time()

        function(value)

        end = time.time()

        # разница между start и end
        # and end time in milli. secs

        res = (end - start) * 10 ** 3

        rounded = round(res, 3)  # округление до трёх знаков после запятой с
                                 # применением встроенной функции round
        print(rounded)

        # Использование оператора %
        print("%.2f" % res)  # округление до трёх знаков после запятой с
        # применением оператора

        # округление до трёх знаков после запятой с спользование метода format()
        print("{:.3f}".format(res))  # Output: 1.93

        print("The time of execution of above program is :",
              (end - start) * 10 ** 3, "ms")

    return timerDecoratorWrap_0

# декорация timeTestFunction_0 с помощью timerDecorator_0
@timerDecorator_0
def timeTestFunction_0(testValue):

    for tst in range(testValue):
        tst+=1

def timerDecorator_1(function):

    def timerDecoratorWrap_1(value):
        # здесь округления не призводится для  обеспечения наглядности
        # процесса изменения значений

        for j in range(10, 5000, 100):
            start = time.time()
            a = 0
            for i in range(j):
                a += (i**2)
                print(f'a == {a}')
                function(value)

                end = time.time()

            # разница между start и end
            # and end time in milli. secs
                print("The time of execution of above program is :",
                (end - start) * 10 ** 3, "ms")

    return timerDecoratorWrap_1


# декорация timeTestFunction_1 с помощью timerDecorator_1
@timerDecorator_1
def timeTestFunction_1(testValue):

    for tst in range(testValue):
        tst+=1


def DoIt():

    print('.....this is DoIt.....')

    xargs = []
    for i in range(10):
        xargs.append(i)

    ret = makers.summator(xargs,0)
    print(ret)
    ret = makers.summator(xargs, '')
    print(ret)
    ret = makers.summator(xargs)
    print(ret)
    ret = Decorators(makers.summator)(xargs,0)
    print(ret)
    ret = Decorators(makers.summator)(xargs,'')
    print(ret)

    print('summator_0 ==========================')
    summator_0(xargs, 0)
    summator_0(xargs, '')
    print('summator_0 ==========================')

    lstArg = [0, '']
    print(summator_1(xargs, lstArg))
    lstArg = ['', 'hello !']
    print(summator_1(xargs, lstArg))
    lstArg = [0,0]
    print(summator_1(xargs, lstArg))

    # вызов декорориванных функций с передачей им больших
    # значений атрибутов
    timeTestFunction_0(1000000)
    #timeTestFunction_1(10000)


#SMPL_0(5, 100)     # Простой несамовзводный итератор

#SMPL_1(50)         # самосбрасываемый итератор

#ScrItr(25)    # Самовзводный итератор
#ScrItr(0)     # Самовзводный итератор

# варианты вызова функции RndItr
#RndItr([25, 10], 100)
#RndItr([], 100)
#RndItr([])
#RndItr([ 1 , 1])

generatorsExample()

GoDecorators_0()
GoDecorators_1([0, 0])

DoIt()

